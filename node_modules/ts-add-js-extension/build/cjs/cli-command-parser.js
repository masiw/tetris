"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var fs_1 = __importDefault(require("fs"));
var path_1 = __importDefault(require("path"));
var package_1 = __importDefault(require("./package"));
var type_1 = require("./type");
var commandKeyWords = {
    help: {
        isMandatory: false,
        keyword: 'help',
    },
    version: {
        isMandatory: false,
        keyword: 'version',
    },
    dir: {
        isMandatory: true,
        keyword: 'dir',
    },
    include: {
        type: 'deprecated',
        isMandatory: false,
        keyword: 'include',
        reason: 'The function `include` is deprecated due to legacy reasons and will be removed in version 2.0',
    },
    showChanges: {
        type: 'deprecated',
        isMandatory: false,
        keyword: 'showchanges',
        reason: 'The function `showchanges` is deprecated in favor of `showprogress` and will be removed in version 2.0',
    },
    showProgress: {
        isMandatory: false,
        keyword: 'showprogress',
    },
    assignment: {
        assign: '=',
        key: '--',
    },
};
var TokenParser = /** @class */ (function () {
    function TokenParser(token) {
        var _this = this;
        this.token = token;
        this.parseVersion = function () {
            var keyword = commandKeyWords.version.keyword;
            if (_this.token.key !== keyword) {
                return {
                    exists: false,
                };
            }
            return {
                type: keyword,
                exists: true,
                value: package_1.default.version,
            };
        };
        this.parseHelp = function () {
            var keyword = commandKeyWords.help.keyword;
            if (_this.token.key !== commandKeyWords.help.keyword) {
                return {
                    exists: false,
                };
            }
            return {
                type: keyword,
                exists: true,
                value: fs_1.default.readFileSync('public/help.md', { encoding: 'utf-8' }),
            };
        };
        this.parseDir = function () {
            var keyword = commandKeyWords.dir.keyword;
            if (_this.token.key !== commandKeyWords.dir.keyword) {
                return {
                    exists: false,
                };
            }
            return {
                type: keyword,
                exists: true,
                value: (0, type_1.guard)({
                    value: _this.token.value.split(' ').at(0),
                    error: new Error('There must be at least one element in values for dir'),
                }),
            };
        };
        this.parseInclude = function () {
            var keyword = commandKeyWords.include.keyword;
            if (_this.token.key !== commandKeyWords.include.keyword) {
                return {
                    exists: false,
                };
            }
            return {
                type: keyword,
                exists: true,
                value: _this.token.value.split(' '),
            };
        };
        this.parseBoolean = function (keyword) {
            return function () {
                var _a = _this.token, key = _a.key, value = _a.value;
                if (key !== keyword) {
                    return {
                        exists: false,
                    };
                }
                if (value === 'true' || value === 'false') {
                    return {
                        type: keyword,
                        exists: true,
                        value: value === 'true',
                    };
                }
                throw new Error("".concat(key, "=").concat(value, " is invalid, it can only receive boolean value"));
            };
        };
        this.parseShowProgress = this.parseBoolean(commandKeyWords.showProgress.keyword);
        this.parseShowChanges = this.parseBoolean(commandKeyWords.showChanges.keyword);
        this.processNonRecognisableToken = function () {
            return {
                type: 'invalid',
                reason: "'".concat(_this.token.key, "'='").concat(_this.token.value, "' token cannot be recognized"),
                token: _this.token,
            };
        };
    }
    return TokenParser;
}());
var ParseArgs = /** @class */ (function () {
    function ParseArgs(args) {
        var _this = this;
        this.tokenize = function (args) {
            var assign = commandKeyWords.assignment.assign;
            return args
                .flatMap(function (arg) {
                if (arg.includes(assign)) {
                    return [arg];
                }
                var _b = arg.split(' '), nullableKey = _b[0], value = _b.slice(1);
                var key = (0, type_1.guard)({
                    value: nullableKey,
                    error: new Error('Key cannot be undefined after being split'),
                });
                return ["".concat(key).concat(assign).concat(value.join(' '))];
            })
                .map(function (args) {
                var _b = args.split(assign), key = _b[0], value = _b[1];
                return {
                    key: (0, type_1.guard)({
                        value: key,
                        error: new Error('Key cannot be undefined after being flat mapped'),
                    }),
                    value: (0, type_1.guard)({
                        value: value,
                        error: new Error('Value cannot be undefined after being flat mapped'),
                    }).trim(),
                };
            });
        };
        this.asVersion = function () {
            return _this.tokens.reduce(function (result, token) {
                if (result.exists) {
                    return result;
                }
                return new TokenParser(token).parseVersion();
            }, {
                exists: false,
            });
        };
        this.asHelp = function () {
            if (!_this.tokens.length) {
                return {
                    type: 'help',
                    exists: true,
                    value: fs_1.default.readFileSync(path_1.default.join('public', 'help.md'), {
                        encoding: 'utf-8',
                    }),
                };
            }
            return _this.tokens.reduce(function (result, token) {
                if (result.exists) {
                    return result;
                }
                return new TokenParser(token).parseHelp();
            }, { exists: false });
        };
        this.asOperation = function () {
            var _b, _c, _d, _e;
            var processedToken = _this.tokens.map(function (token) {
                var parser = new TokenParser(token);
                var dir = parser.parseDir();
                if (dir.exists) {
                    return dir;
                }
                var include = parser.parseInclude();
                if (include.exists) {
                    return include;
                }
                var showChanges = parser.parseShowChanges();
                if (showChanges.exists) {
                    return showChanges;
                }
                var showProgress = parser.parseShowProgress();
                if (showProgress.exists) {
                    return showProgress;
                }
                return parser.processNonRecognisableToken();
            });
            processedToken.forEach(function (node) {
                if (node.type === 'showchanges') {
                    console.warn(commandKeyWords.showChanges.reason);
                }
                else if (node.type === 'include') {
                    console.warn(commandKeyWords.include.reason);
                }
            });
            processedToken
                .flatMap(function (node) {
                return node.type !== 'invalid' ? [] : [node];
            })
                .forEach(function (node) {
                console.log("The \"".concat(JSON.stringify(node.token, undefined, 4), "\" in the command is invalid as ").concat(node.reason, ". So please remove it"));
            });
            var nodes = processedToken.flatMap(function (node) {
                return node.type === 'invalid' ? [] : [node];
            });
            return {
                dir: (0, type_1.guard)({
                    value: (_b = nodes.find(function (node) {
                        return node.type === 'dir';
                    })) === null || _b === void 0 ? void 0 : _b.value,
                    error: new Error('dir is a mandatory field, it should be present to know which dir it should operate on'),
                }),
                // optional
                /**
                 * @deprecated
                 * Will be removed in version 2.0
                 * */
                include: (_c = nodes.find(function (node) {
                    return node.type === 'include';
                })) === null || _c === void 0 ? void 0 : _c.value,
                /**
                 * @deprecated
                 * Will be removed in version 2.0
                 * `showChanges` is deprecated in favor of `showProgress`
                 * */
                showChanges: (_d = nodes.find(function (node) {
                    return node.type === 'showchanges';
                })) === null || _d === void 0 ? void 0 : _d.value,
                showProgress: (_e = nodes.find(function (node) {
                    return node.type === 'showprogress';
                })) === null || _e === void 0 ? void 0 : _e.value,
            };
        };
        this.tokens = this.tokenize(args);
    }
    var _a;
    _a = ParseArgs;
    ParseArgs.create = function (arg) {
        var tokens = arg.split(commandKeyWords.assignment.key);
        var result = _a.checkPackageName(tokens.at(0));
        if (result.isInvalid) {
            throw result.error;
        }
        if (tokens.includes('add')) {
            console.log('The "add" in the command can be removed, as it is only used for backward compatibility');
        }
        return new _a(tokens
            .map(function (token) {
            return token === 'add' ? '' : token;
        })
            .slice(1));
    };
    ParseArgs.checkPackageName = function (name) {
        var packageName = (0, type_1.guard)({
            value: name,
            error: new Error('The pkg name is undefined'),
        });
        return packageName.includes(package_1.default.name)
            ? {
                isInvalid: false,
            }
            : {
                isInvalid: true,
                error: new Error("The pkg name \"".concat(packageName, "\" passed is invalid")),
            };
    };
    return ParseArgs;
}());
exports.default = ParseArgs;
//# sourceMappingURL=cli-command-parser.js.map