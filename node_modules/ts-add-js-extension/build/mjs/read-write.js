import fs from "fs";
import path from "path";
import tsc from "typescript";
import { matchEither, separator } from "./const.js";
import Log from "./log.js";
import traverseAndUpdateFile from "./traverse-and-update.js";
const getAllJSAndDTSFiles = (directory) => {
    return fs.readdirSync(directory).flatMap((file) => {
        const filePath = path.posix.join(directory.split(path.sep).join(separator), file);
        if (fs.statSync(filePath).isDirectory()) {
            return getAllJSAndDTSFiles(filePath);
        }
        return !matchEither(filePath) ? [] : [filePath];
    });
};
const readCode = (file) => {
    return new Promise((resolve, reject) => {
        const code = [];
        fs.createReadStream(file)
            .on("data", (data) => {
            code.push(data.toString());
        })
            .on("end", () => {
            resolve(code.join(""));
        })
            .on("error", reject);
    });
};
const getAllJSAndDTSMetainfo = (files) => {
    return files.map(async (file) => {
        const code = await readCode(file);
        return {
            files,
            code,
            sourceFile: tsc.createSourceFile(file, code, tsc.ScriptTarget.ESNext),
        };
    });
};
const findMany = async (props) => {
    // user may import files from `common` into `src`
    const files = props.include.concat(props.dir).flatMap(getAllJSAndDTSFiles);
    return await Promise.all(getAllJSAndDTSMetainfo(files));
};
const writeMany = async (props) => {
    const transformed = props.foundMany.flatMap(traverseAndUpdateFile);
    const repeat = transformed.reduce((longestFileName, { file }) => {
        return Math.max(longestFileName, file.length);
    }, 0);
    const log = !(transformed.length && props.showProgress)
        ? undefined
        : Log.fromNumberOfFiles(transformed.length);
    try {
        const errors = (await Promise.all(transformed.map(({ code, file }) => {
            return new Promise((resolve) => {
                return fs.writeFile(file, code, (error) => {
                    log?.increment({
                        repeat,
                        file,
                        succeed: !error,
                    });
                    resolve(!error
                        ? undefined
                        : {
                            file,
                            error,
                        });
                });
            });
        }))).flatMap((element) => {
            return !element ? [] : [element];
        });
        log?.end({ errors });
        return {
            type: "done",
        };
    }
    catch (error) {
        return {
            type: "error",
            error,
        };
    }
};
export { findMany, writeMany };
//# sourceMappingURL=read-write.js.map
